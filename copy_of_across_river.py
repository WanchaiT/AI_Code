# -*- coding: utf-8 -*-
"""Copy of across_river.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ze7ho8IqC41XrcC5_SLRxeg8qGdluRAo
"""

class Queue:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def enqueue(self, item):
        self.items.insert(0,item)

    def add(self, item):
        self.items.append(item)

    def dequeue(self):
        return self.items.pop()

    def size(self):
        return len(self.items)

    def show(self):
        print(self.items)

def isTrueState(state):
  a = {'Fo','Go'}
  b = {'Go','Gr'}
  c = {'As'}
  return not(a <= state[0] and not c <= state[0] or a <= state[1] and not c <= state[1] or b <= state[0] and not c <= state[0] or b <= state[1] and not c <= state[1])

def findNextState(sPre,set_s):
  a = set(sPre[0])
  b = set(sPre[1])
  s = [a,b]
  listState = []
  if "As" in s[0]:
    s[0] = s[0] - {"As"}
    childs = list(s[0])
    s[1].add("As")
    if not ([s[0],s[1]] in set_s) and isTrueState([s[0],s[1]]):
        listState = [[s[0],s[1]]]
    for i in childs:
        if isTrueState([ s[0]-{i}, set(list(s[1])+[i]) ]):
            listC = [ s[0]-{i}, set(list(s[1])+[i]) ]
            if not (listC in set_s):
                listState = listState + [listC]
  else:
    s[1] = s[1] - {"As"}
    childs = list(s[1])
    s[0].add("As")
    if not ([s[0],s[1]] in set_s) and isTrueState([s[0],s[1]]):
        listState = [[s[0],s[1]]]
    for i in childs:
        if isTrueState([set(list(s[0])+[i]) , s[1]-{i}]):
            listC = [set(list(s[0])+[i]) , s[1]-{i} ]
            if not (listC in set_s):
                listState = listState + [listC]
  return listState

def isGoal(state):
  return len(state[0]) == 0

def findGoal(Q,set_s):
    if Q.isEmpty():         #2
        return False
    else:
        N = Q.dequeue()
        if isGoal(N[-1]):   #3 N[-1] = last list
            return N
        else:               #4
            listState = findNextState(N[-1],set_s)
            for i in listState:
                part = N + [i]
                Q.add(part)
                set_s = set_s + [i]
            return findGoal(Q,set_s)

stateS = [{"Go","Gr","As","Fo",},{}]
set_s = [stateS]
Q = Queue()
Q.add([stateS])
partial = findGoal(Q,set_s)
if not partial:
    print("No way")
else:
    for i in range(len(partial)):
      print("State "+str(i)+" : "+" "+str(partial[i][0])+" แม่น้ำ "+str(partial[i][1])+"\n")
